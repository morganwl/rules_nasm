# Example: Cross-compilation

Example demonstrating use of `rules_nasm` when the target architecture
does not match the host.

## Requirements

This example uses tools installed on the host computer, making it
non-hermetic. Cross-platform tooling must be installed by the user.
Tools are listed by their Debian package names.

- gcc-12-x86-64-linux-gnu (elf64 targets)
- qemu-user (to test produced binaries)

On Debian, Ubuntu, or any other Debian-based system, packages can be
installed:
```
sudo apt-get install gcc-12-x86-64-linux-gn qemu-user
```

## Supported Execution Platforms

This example has been tested on an ARMv7 platform, running the 64-bit
RaspbianOS.

## Demo

On a Linux system, the example can be demoed:

```
bazel build //... --platforms=@rules_nasm//platforms:elf64
qemu-x86_64 -L /usr/x86_64-linux-gnu/ bazel-bin/hello/hello
```

## Explanation

The `nasm` tool can target any supported x86 system, but `rules_nasm`
uses the C++ toolchain to link object files generated by `nasm`. This
example shows one way to configure an appropriate C++ toolchain, but a
hermetic cross-compilation toolchain would work just as well.

The `@rules_nasm//platforms` package contains platform definitions
matching all supported binary formats, but any platform which sets the
`os` and `cpu` constraint values will suffice.
